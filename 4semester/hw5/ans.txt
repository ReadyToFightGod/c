1) О чем надо подумать перед распараллеливанием программы?
Стоит ли вообще это делать - т.к. не очень обьемные программы спокойно можно выполнить на 1 ядре. 
Мы не знаем, какой поток закончит работу первым - нет никакой очередности выполнения (т.к. все происходит "одновременно") 
Мы не знаем, в какой момент поток закончит работу - т.е. наша распараллеленная прога может встать в очередь на выполнение и "застрять"

2) Основные подходы к организации паралеллизма.
-std::thread. Делим прогу на несколько потоков, причем тот, к котором мы это делаем будет родительским. Если родительский поток 
завершает исполнение раньше, чем дочерние, то дочерние умирают (тут же завершаются, обычно некорректно). Т.е их нужно ждать: thread.join().
Есть проблема с тем, что поведение потока не определено (как раз про раннее завершение) и они могут конкурировать за общий ресурс - какой-нибудь
глобальный объект типа std::cout.

-std::future. Это контракт на выполнение функции. Существует два варианта: действие производится сразу же или только когда мы попросим. 
Future.get() - Взять значение из функции.
